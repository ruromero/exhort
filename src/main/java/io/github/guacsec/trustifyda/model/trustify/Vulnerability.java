/*
 * Copyright 2023-2025 Trustify Dependency Analytics Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package io.github.guacsec.trustifyda.model.trustify;

import java.io.IOException;

import com.fasterxml.jackson.core.JsonParser;
import com.fasterxml.jackson.databind.DeserializationContext;
import com.fasterxml.jackson.databind.JsonDeserializer;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.annotation.JsonDeserialize;

import io.quarkus.runtime.annotations.RegisterForReflection;

@RegisterForReflection
public class Vulnerability {

  private String id;
  private Status status;
  private Justification justification;

  public Vulnerability(String id, Status status, Justification justification) {
    this.id = id;
    this.status = status;
    this.justification = justification;
  }

  public Vulnerability() {}

  public String getId() {
    return id;
  }

  public void setId(String id) {
    this.id = id;
  }

  public Status getStatus() {
    return status;
  }

  public void setStatus(Status status) {
    this.status = status;
  }

  public Justification getJustification() {
    return justification;
  }

  public void setJustification(Justification justification) {
    this.justification = justification;
  }

  @JsonDeserialize(using = JustificationDeserializer.class)
  public sealed interface Justification permits JustificationEnum, JustificationOther {
    static String toString(Justification j) {
      if (j == null) {
        return "null";
      }
      if (j instanceof JustificationEnum e) {
        return e.name();
      }
      if (j instanceof JustificationOther o) {
        return o.other();
      }
      return "unknown";
    }
  }

  public static enum JustificationEnum implements Justification {
    ComponentNotPresent,
    VulnerableCodeNotPresent,
    VulnerableCodeNotInExecutePath,
    VulnerableCodeCannotBeControlledByAdversary,
    InlineMitigationsAlreadyExist,
    NotProvided
  }

  @JsonDeserialize(using = StatusDeserializer.class)
  public sealed interface Status permits StatusEnum, StatusOther {
    static String toString(Status j) {
      if (j == null) {
        return "null";
      }
      if (j instanceof StatusEnum e) {
        return e.name();
      }
      if (j instanceof StatusOther o) {
        return o.other();
      }
      return "unknown";
    }
  }

  public static enum StatusEnum implements Status {
    Affected,
    UnderInvestigation,
    NotAffected,
    Fixed,
    Recommended
  }

  public record JustificationOther(String other) implements Justification {}

  public record StatusOther(String other) implements Status {}

  public static class StatusDeserializer extends JsonDeserializer<Status> {
    @Override
    public Status deserialize(JsonParser p, DeserializationContext ctxt) throws IOException {
      JsonNode node = p.getCodec().readTree(p);

      // Enum case
      if (node.isTextual()) {
        String text = node.asText();
        try {
          if (text == null || text.isEmpty()) {
            return null;
          }
          return StatusEnum.valueOf(text);
        } catch (IllegalArgumentException ex) {
          return new StatusOther(text);
        }
      }

      // Object with "Other" key
      if (node.isObject() && node.has("Other")) {
        return new StatusOther(node.get("Other").asText());
      }

      return null;
    }
  }

  public static class JustificationDeserializer extends JsonDeserializer<Justification> {
    @Override
    public Justification deserialize(JsonParser p, DeserializationContext ctxt) throws IOException {

      JsonNode node = p.getCodec().readTree(p);

      // Enum case
      if (node.isTextual()) {
        String text = node.asText();
        try {
          if (text == null || text.isEmpty()) {
            return null;
          }
          return JustificationEnum.valueOf(text);
        } catch (IllegalArgumentException ex) {
          return new JustificationOther(text);
        }
      }

      // Object with "Other" key
      if (node.isObject() && node.has("Other")) {
        return new JustificationOther(node.get("Other").asText());
      }

      return null;
    }
  }
}
